# 网络

## 网络模型
5层因特网协议栈：应用层、运输层、网络层、链路层、物理层。

7层ISO 开放系统互连（OSI）模型：应用层、```表示层```、```会话层```、运输层、网络层、链路层、物理层。

## HTTP

HTTP由两个程序实现：一个客户程序和一个服务器程序。

客户向它的套接字接口发送HTTP请求报文并从它的套接字接口接收HTTP响应报文。类似地，服务器从它的套接字接口接收HTTP请求报文和向它的套接字接口发送HTTP响应报文。

因为HTTP服务器不保存关于客户的任何信息，所以我们说HTTP是一个无状态协议。

非持续连接：每个请求/响应对是经一个单独的TCP连接发送。持续连接：所有的请求及其响应经相同的TCP连接发送。

### 往返时间
往返时间（Round-Trip Time，RTT)：该时间指一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包含分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。

对于非持续性连接来说，粗略的总响应时间就是两个RTT加上服务器传输HTML文件的时间。

## HTTP/1.1、HTTP/2

HTTP/1.1 开始允许持续连接，默认开启。

HTTP/2在HTTP/1.1的基础上允许多个请求和回答交错，并增加了在该连接中优化HTTP报文请求和回答的机制。

## HTTP请求报文和响应报文

```js
//请求行   方法 URL 版本
// 首部行  首部字段名： 值
// 。。。更多的首部行

// 实体体
```

```js
// 状态行   版本 状态码 短语
// 首部行   首部字段名： 值
// 。。。更多的首部行

//实体体
```

### 常见状态码
200 OK：请求成功

301 Moved Permanently: 请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL。

400 Bad Request：一个通用错误代码，指示该请求不能被服务器理解。

404 Not Found：被请求的文档不在服务器上。

505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP版本。

## cookie
1. 在HTTP响应报文中有一个Set-cookie首部行
2. 在HTTP请求报文中有一个cookie首部行
3. 在用户端系统中保留一个cookie文件，并由用户的浏览器进行管理
4. 位于Web站点的一个后端数据库

## Web缓存器
也叫代理服务器，能够代表初始Web服务器来满足HTTP请求的网络实体。

Web缓存器既是服务器又是客户。

Web缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的带宽时。

## DNS
由分层的DNS服务器实现的分布式数据库，使得主机能够查询IP地址。DNS协议运行在UDP上，使用53号端口。

DNS提供的服务：
1. 主机名到IP地址的转换
2. 主机可以有多个主机别名，其中一个为规范主机名
3. 邮件服务器别名
4. 负载分配，一个IP地址集合可以与同一个规范主机名相联系，引导客户向其中一个IP地址发送请求。

DNS服务器分为根DNS服务器、顶级域（Top-Level Domain，TLD）DNS服务器、权威DNS服务器和本地DNS服务器。

从请求主机到本地DNS服务器是递归的，本地DNS向其他服务器查询是迭代的。

## 多路复用与多路分解
将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。

在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用。


## UDP
UDP提供一种不可靠数据传输服务，UDP协议并不保证该报文将到达接收进程，到达接收进程的报文也可能是乱序到达的。UDP的发送端可以用它选定的任何速率向其下层（网络层）注入数据。

UDP是无连接的。

### UDP报文段结构
```
源端口号 目的端口号
长度 检验和
应用数据（报文）
```

UDP首部只有4个字段，每个字段由两个字节组成

### UDP检验和
发送方的UDP对报文段的比特求和，求和时遇到的任何溢出都要被回卷，之后再进行反码运算。


## TCP和UDP在应用层
通常使用TCP的应用：
1. 电子邮件 SMTP
2. 远程终端访问 Telnet
3. Web HTTP
4. 文件传输 FTP


通常使用UDP的应用：
1. 远程文件服务器 NFS
2. 网络管理 SNMP
3. 名字转换 DNS

可能同时使用UDP和TCP：
1. 流式多媒体
2. 因特网电话/视频会议，由于安全原因可能会阻塞UDP流量，TCP可以作为备选

## TCP

### TCP连接
三次握手：
1. 客户端向服务器端TCP SYN报文段，也就是标志位的SYN比特被置为1。同时客户端随机选择一个初始序号（client_isn）放进序号字段。
2. 服务器端接收到客户端发来的SYN，返回一个确认号字段设置为client_isn+1的SYN报文，并选择自己的初始序号server_isn。这个server_isn同时还兼具验证客户端请求合法性的作用，只有合法的请求才会在三次握手完成后服务器才会正式分配资源。该报文段也被称为SYNACK报文段。
3. 收到SYNACK后，客户端分配缓存和变量给该连接，并向服务器发送SYN字段为0，确认号为server_isn+1的报文。客户端可以在这报文的负载中携带客户到服务器的数据。服务器在确认了这个报文后也会开始分配资源。

四次挥手：
1. 客户端向服务器端发送FIN字段为1的报文
2. 服务器接收到FIN报文后，向发送方回送一个确认报文段，也就是ACK
3. 然后服务器发送自己的终止报文段，FIN
4. 最后客户端再对这个服务器的FIN进行确认

**客户端的TCP状态序列**

CLOSED -> SYN_SENT -> ESTABLISHED -> FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT -> CLOSED

**服务器端的TCP状态序列**

CLOSED -> LISTEN -> SYN_RCVD -> ESTABLISHED -> CLOSE_WAIT -> LAST_ACK -> CLOSED

### 超时长度的设置
为了计算超时长度，首先需要估计往返时间（RTT）。报文段的样本RTT（SampleRTT)是某报文段从被发出到对该报文段的确认被收到之间的时间量。TCP维持一个样本RTT的均值（EstimatedRTT），计算公式：

```
EstimatedRTT = (1 - k) * EstimatedRTT + k * SampleRTT
```
RTT偏差（DevRTT），用于估算SampleRTT偏离EstimatedRTT的程度：

```
DevRTT = (1 - ß) * DevRTT + ß * | SampleRTT - EstimatedRTT |
```

超时间隔（TimeoutInterval)，推荐的初始值为1秒，当超时出现后加倍。一旦收到报文段并更新EstimatedRTT，按照这个公式计算TimeoutInterval：

```
TimeoutInterval = EstimatedRTT + 4 * DevRTT
```

### 可靠数据传输

机制|用途和说明
-----|----------
检验和|用于检测一个传输分组中的比特错误
定时器|用于超时/重传一个分组，可能因为该分组（或其ACK）在信道中丢失了。由于当一个分组延时但未丢失（过早超时），或当一个分组已被接收方收到但发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本
序号|用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的间隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本
确认|接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议
否定确认|接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常携带着未被正确接收的分组的序号
窗口、流水线|发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者情况来进行设置

在TCP中，只有单一的重传定时器。当开始传递报文段时，如果定时器还未被启用，开启定时器。

超时导致TCP通过重传引起超时的报文段来响应超时事件。然后TCP重启定时器。超时的时候将超时间隔加倍，然后在收到ACK或者接收上层应用数据时由公式重新计算。

如果在超时之前收到三个冗余的ACK，TCP就会执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。

当收到ACK时，TCP将ACK的序号和状态变量SendBase进行比较，也就是最早的未被确认的序号。因为TCP采用累积确认，如果ACK的编号大于SendBase，则该ACK是在确认一个或多个先前未被确认的报文段。发送方更新自己的SendBase，然后重启定时器。

TCP为它的应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能性。流量控制是一个速度匹配服务。流量控制和拥塞控制采取的动作非常相似，都是对发送方的遏制。然而它们是针对不同的原因采取的措施。流量控制为了不让发送方发送的速度过快导致接收方无法接收到报文段，而拥塞控制为了不让发送方将传输线路上的网络阻塞而导致更多的重传。简单说就是针对网络中的不同实体。

TCP让发送方维持一个接收窗口来表示接收方还有多少可用的缓存空间。接收方的接收缓存（RcvBuffer），同时对于接收方有：
```
LastByteRead，接收方上的应用程序从缓存读出的数据流的最后一个字节的编号
LastByteRcvd，从网络中到达的并且已放入接收方接收缓存中的数据流的最后一个字节的编号

LastByteRcvd - LastByteRead <= RcvBuffer


接收窗口rwnd：

rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)

类似的，发送方上有：

LastByteSent - LastByteAcked <= rwnd
```
当rwnd为0时，发送方不间断发送只有一个字节数据的报文段。当接收方能够确认时，确认报文中将包含一个非0的rwnd值。

### 拥塞控制
TCP让每一个发送方根据所**感知**到的网络拥塞程度来**限制**其能向连接发送流量的速率。这里面有三个方面：如何限制、如何感知、采用何种算法改变发送速率。

TCP在发送方跟踪一个变量，拥塞窗口（cwnd），在一个发送方中未被确认的数据量不会超过cwnd和rwnd中的最小值：
```
LastByteSent - LastByteAcked <= min {cwnd, rwnd}
```
