# 网络

## [HTTP1/2/3](./http123.md)

## 网络模型
5层因特网协议栈：应用层、运输层、网络层、链路层、物理层。

7层ISO 开放系统互连（OSI）模型：应用层、```表示层```、```会话层```、运输层、网络层、链路层、物理层。

## HTTP

HTTP由两个程序实现：一个客户程序和一个服务器程序。

客户向它的套接字接口发送HTTP请求报文并从它的套接字接口接收HTTP响应报文。类似地，服务器从它的套接字接口接收HTTP请求报文和向它的套接字接口发送HTTP响应报文。

因为HTTP服务器不保存关于客户的任何信息，所以我们说HTTP是一个无状态协议。

非持续连接：每个请求/响应对是经一个单独的TCP连接发送。持续连接：所有的请求及其响应经相同的TCP连接发送。

### 往返时间
往返时间（Round-Trip Time，RTT)：该时间指一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包含分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。

对于非持续性连接来说，粗略的总响应时间就是两个RTT加上服务器传输HTML文件的时间。

## HTTPS
HTTPS通过SSL提供安全性。

安全通信需要提供：机密性、报文完整性、端点鉴别、运行安全性。

### 初始向量
块密码中使用密码块链接（Cipher Block Chaining, CBC）来增加随机性，同时不会大量增加所需带宽。CBC的基本思想是仅随第一个报文发送一个随机值，然后让发送方和接收方使用计算的编码块代替后继的随机数。

这里面的初始随机值就是初始向量（Initialization, IV），假设为c(0)，第一块明文，m(1)，先计算第一块明文与IV的异或，然后通过块密码算法运行得到的结果以得到对应的密文块，c(1)。后续的密文块都通过同样的方式得出，接收方利用解密之后的结果和上一次的密文块就可以获得明文。

### SSL的三个阶段
握手、密钥导出、数据传输

1. 创建一条TCP连接
2. 客户发送它支持的密码算法的列表，连同一个客户的不重数。
3. 服务器从列表中选择算法，连同自己的证书和一个服务器不重数返回给客户。
4. 客户端通过CA的公钥验证服务器的证书。验证通过，拿到服务器的公钥，生成一个前主密钥（Pre-Master Secret, PMS），用服务器的公钥加密该PMS，并将加密的PMS发给服务器。
5. 客户端和服务器独立地从PMS和不重数中计算出主密钥（Master Secret, MS）。然后将MS切片生成两个密钥和两个MAC密钥，分别用于服务器端和客户端的加密和鉴别（报文完整性也称为报文鉴别）。当选择的对成密码应用于CBC，则两个初始向量也从该MS中获得。
6. 客户端发送所有握手报文的一个MAC
7. 服务器发送所有握手报文的一个MAC

最后两个步骤使握手免受篡改危害。不重数用于防御“连接重放”。

生成的MAC密钥用于在整个会话过程中提供完整性检查。TCP是一种字节流协议，SSL将数据流分割成记录，对每个记录附加一个MAC用于完整性检查，然后加密该记录和MAC。

SSL还用序号防御诸如重排序或重放报文段等中间人攻击。发送方维护一个序号计数器，初始为0，每发送一个SSL记录增加1。MAC由数据加MAC密钥加当前序号的散列而来。

一个SSL记录由类型、版本、长度、数据和MAC字段组成。数据和MAC经过加密。

通过类型字段可以防御截断攻击（即攻击者提前关闭一个还在进行中的SSL会话）。在类型字段中指出该记录是否是用于终止一个SSL会话的。尽管SSL类型是以明文形式发送的，但在接收方使用了记录的MAC对它进行了鉴别。如果在一个关闭SSL记录之前突然收到了一个TCP FIN，说明可能发生了截断攻击。

## HTTP/1.1、HTTP/2

HTTP/1.1 开始允许持续连接，默认开启。

HTTP/2在HTTP/1.1的基础上允许多个请求和回答交错，并增加了在该连接中优化HTTP报文请求和回答的机制。

## HTTP请求报文和响应报文

```js
//请求行   方法 URL 版本
// 首部行  首部字段名： 值
// 。。。更多的首部行

// 实体体
```

```js
// 状态行   版本 状态码 短语
// 首部行   首部字段名： 值
// 。。。更多的首部行

//实体体
```

### 常见状态码
200 OK：请求成功

301 Moved Permanently: 请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL。

302 Move Temporarily

304 Not Modified：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。

400 Bad Request：一个通用错误代码，指示该请求不能被服务器理解。

401 Unauthorized：客户端提交的请求没有正确的```Authorization```头部信息。

403 Forbidden：服务器已经理解请求，但是拒绝执行它。

404 Not Found：被请求的文档不在服务器上。

405 Method Not Allowed：请求使用的方法不在```Allow```接收的范围内。

406 Not Acceptable：请求的资源的内容特性和```Content-type```允许的范围不匹配

500 Internal Server Error：服务器代码错误

502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应


505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP版本。

## cookie
1. 在HTTP响应报文中有一个Set-cookie首部行
2. 在HTTP请求报文中有一个cookie首部行
3. 在用户端系统中保留一个cookie文件，并由用户的浏览器进行管理
4. 位于Web站点的一个后端数据库

## Web缓存器
也叫代理服务器，能够代表初始Web服务器来满足HTTP请求的网络实体。

Web缓存器既是服务器又是客户。

Web缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的带宽时。

## DNS
由分层的DNS服务器实现的分布式数据库，使得主机能够查询IP地址。DNS协议运行在UDP上，使用53号端口。

DNS提供的服务：
1. 主机名到IP地址的转换
2. 主机可以有多个主机别名，其中一个为规范主机名
3. 邮件服务器别名
4. 负载分配，一个IP地址集合可以与同一个规范主机名相联系，引导客户向其中一个IP地址发送请求。

DNS服务器分为根DNS服务器、顶级域（Top-Level Domain，TLD）DNS服务器、权威DNS服务器和本地DNS服务器。

从请求主机到本地DNS服务器是递归的，本地DNS向其他服务器查询是迭代的。

## 多路复用与多路分解
将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。

在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用。


## UDP
UDP提供一种不可靠数据传输服务，UDP协议并不保证该报文将到达接收进程，到达接收进程的报文也可能是乱序到达的。UDP的发送端可以用它选定的任何速率向其下层（网络层）注入数据。

UDP是无连接的。

### UDP报文段结构
```
源端口号 目的端口号
长度 检验和
应用数据（报文）
```

UDP首部只有4个字段，每个字段由两个字节组成

### UDP检验和
发送方的UDP对报文段的比特求和，求和时遇到的任何溢出都要被回卷，之后再进行反码运算。


## TCP和UDP在应用层
通常使用TCP的应用：
1. 电子邮件 SMTP
2. 远程终端访问 Telnet
3. Web HTTP
4. 文件传输 FTP


通常使用UDP的应用：
1. 远程文件服务器 NFS
2. 网络管理 SNMP
3. 名字转换 DNS

可能同时使用UDP和TCP：
1. 流式多媒体
2. 因特网电话/视频会议，由于安全原因可能会阻塞UDP流量，TCP可以作为备选

## TCP

### TCP连接
三次握手：
1. 客户端向服务器端TCP SYN报文段，也就是标志位的SYN比特被置为1。同时客户端随机选择一个初始序号（client_isn）放进序号字段。
2. 服务器端接收到客户端发来的SYN，返回一个确认号字段设置为client_isn+1的SYN报文，并选择自己的初始序号server_isn。这个server_isn同时还兼具验证客户端请求合法性的作用，只有合法的请求才会在三次握手完成后服务器才会正式分配资源。该报文段也被称为SYNACK报文段。
3. 收到SYNACK后，客户端分配缓存和变量给该连接，并向服务器发送SYN字段为0，确认号为server_isn+1的报文。客户端可以在这报文的负载中携带客户到服务器的数据。服务器在确认了这个报文后也会开始分配资源。

四次挥手：
1. 客户端向服务器端发送FIN字段为1的报文
2. 服务器接收到FIN报文后，向发送方回送一个确认报文段，也就是ACK
3. 然后服务器发送自己的终止报文段，FIN
4. 最后客户端再对这个服务器的FIN进行确认

**客户端的TCP状态序列**

CLOSED -> SYN_SENT -> ESTABLISHED -> FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT -> CLOSED

**服务器端的TCP状态序列**

CLOSED -> LISTEN -> SYN_RCVD -> ESTABLISHED -> CLOSE_WAIT -> LAST_ACK -> CLOSED

### 超时长度的设置
为了计算超时长度，首先需要估计往返时间（RTT）。报文段的样本RTT（SampleRTT)是某报文段从被发出到对该报文段的确认被收到之间的时间量。TCP维持一个样本RTT的均值（EstimatedRTT），计算公式：

```
EstimatedRTT = (1 - k) * EstimatedRTT + k * SampleRTT
```
RTT偏差（DevRTT），用于估算SampleRTT偏离EstimatedRTT的程度：

```
DevRTT = (1 - ß) * DevRTT + ß * | SampleRTT - EstimatedRTT |
```

超时间隔（TimeoutInterval)，推荐的初始值为1秒，当超时出现后加倍。一旦收到报文段并更新EstimatedRTT，按照这个公式计算TimeoutInterval：

```
TimeoutInterval = EstimatedRTT + 4 * DevRTT
```

### 可靠数据传输

机制|用途和说明
-----|----------
检验和|用于检测一个传输分组中的比特错误
定时器|用于超时/重传一个分组，可能因为该分组（或其ACK）在信道中丢失了。由于当一个分组延时但未丢失（过早超时），或当一个分组已被接收方收到但发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本
序号|用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的间隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本
确认|接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议
否定确认|接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常携带着未被正确接收的分组的序号
窗口、流水线|发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者情况来进行设置

在TCP中，只有单一的重传定时器。当开始传递报文段时，如果定时器还未被启用，开启定时器。

超时导致TCP通过重传引起超时的报文段来响应超时事件。然后TCP重启定时器。超时的时候将超时间隔加倍，然后在收到ACK或者接收上层应用数据时由公式重新计算。

如果在超时之前收到三个冗余的ACK，TCP就会执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。

当收到ACK时，TCP将ACK的序号和状态变量SendBase进行比较，也就是最早的未被确认的序号。因为TCP采用累积确认，如果ACK的编号大于SendBase，则该ACK是在确认一个或多个先前未被确认的报文段。发送方更新自己的SendBase，然后重启定时器。

### 流量控制

TCP为它的应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能性。流量控制是一个速度匹配服务。流量控制和拥塞控制采取的动作非常相似，都是对发送方的遏制。然而它们是针对不同的原因采取的措施。流量控制为了不让发送方发送的速度过快导致接收方无法接收到报文段，而拥塞控制为了不让发送方将传输线路上的网络阻塞而导致更多的重传。简单说就是针对网络中的不同实体。

TCP让发送方维持一个接收窗口来表示接收方还有多少可用的缓存空间。接收方的接收缓存（RcvBuffer），同时对于接收方有：
```
LastByteRead，接收方上的应用程序从缓存读出的数据流的最后一个字节的编号
LastByteRcvd，从网络中到达的并且已放入接收方接收缓存中的数据流的最后一个字节的编号

LastByteRcvd - LastByteRead <= RcvBuffer


接收窗口rwnd：

rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)

类似的，发送方上有：

LastByteSent - LastByteAcked <= rwnd
```
当rwnd为0时，发送方不间断发送只有一个字节数据的报文段。当接收方能够确认时，确认报文中将包含一个非0的rwnd值。

### 拥塞控制
TCP让每一个发送方根据所**感知**到的网络拥塞程度来**限制**其能向连接发送流量的速率。这里面有三个方面：如何限制、如何感知、采用何种算法改变发送速率。

TCP在发送方跟踪一个变量，拥塞窗口（cwnd），在一个发送方中未被确认的数据量不会超过cwnd和rwnd中的最小值：
```
LastByteSent - LastByteAcked <= min {cwnd, rwnd}
```

当出现拥塞时，在一条路径上的一台或多台路由器的缓存会溢出，引起丢包，发送方要么发现超时要么收到3个冗余ACK。

TCP的拥塞控制遵循以下原则：
1. 一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的发送速率
2. 一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率
3. TCP调节传输速率的策略是ACK到达时增加速率，遇到丢包事件时减小传输速率

### TCP拥塞控制算法
包含三个部分：慢启动、拥塞避免、快速恢复

**慢启动**
1. 初始一个MSS的cwnd（MSS是根据最大链路层长度去掉TCP/IP首部设置的）。发送方对每个确认的报文段都会将发送速率翻倍。
2. 如果发生超时，设置ssthresh（慢启动阈值）为cwnd/2，cwnd重置为1并重新开始慢启动。
3. 当前cwnd到达或超过ssthresh时，从慢启动转移到拥塞避免。
4. 如果检测到三个冗余ACK，执行快速重传，进入快速恢复。

**拥塞避免**
1. 进入拥塞避免后，cwnd每个RTT增加一个单位。
2. 如果发生超时，设置ssthresh（慢启动阈值）为cwnd/2，cwnd重置为1并进入慢启动。
3. 如果检测到三个冗余ACK，记录ssthresh为cwnd的一半，更新cwnd为ssthresh（旧cwnd的一半）加上3个单位，进入快速恢复

**快速恢复**
1. 对于每个冗余的ACK，cwnd增加一个单位。
2. 当对丢失报文段的一个ACK到达时，cwnd降低为ssthresh后进入拥塞避免
3. 如果发生超时，设置ssthresh（慢启动阈值）为cwnd/2，cwnd重置为1并进入慢启动。

## [websocket](webSocket.md)