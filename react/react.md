# React


## 合成事件

SyntheticEvent 实例将被传递给你的事件处理函数，它是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。

SyntheticEvent 是合并而来。这意味着 SyntheticEvent 对象可能会被重用，而且在事件回调函数被调用后，所有的属性都会无效。出于性能考虑，你不能通过异步访问事件。

## Virtual DOM
Virtual DOM是一种编程理念，通过状态生成一个虚拟的节点树，然后使用虚拟节点树进行渲染。渲染之前，会使用新生成的节点树和上一次生成的节点树进行比对，只渲染不同的部分。

## setState
setState() 将对组件 state 的更改排入队列。出于性能考虑，React可能会批量更新state，因而setState看起来像是异步的。React内部通过队列缓存了setState。

需要使用最新的state和props时，应该使用setState()的updater参数。
```js
(state, props) => stateChange
```

例如：
```js
this.setState((state, props) => {
  return {counter: state.counter + props.step};
});
```
updater 函数中接收的 state 和 props 都保证为最新。updater 的返回值会与 state 进行浅合并。

setState() 的第二个参数为可选的回调函数，它将在 setState 完成合并并重新渲染组件后执行。通常，我们建议使用 componentDidUpdate() 来代替此方式。

## React diff
传统的diff算法效率低下，算法复杂度达到O(n3)。React将Virtual DOM树转换成actual DOM树的最少操作的过程称为调和（reconciliation），diff算法是调和的具体实现。React通过大胆的假设，将O（n3）复杂度的问题转变为O（n）的问题。

### React基于两个假设
1. 两个不同类型的元素会产生出不同的树；
2. 开发者可以通过 `key` prop 来暗示哪些子元素在不同的渲染下能保持稳定；

### React diff的三个策略：
1. Web UI中的DOM节点跨层级的移动操作特别少
2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生产不同的树形结构。
3. 对于同一层级的一组子节点，可以通过唯一id进行区分。

## 树diff

对比两棵树时，首先比较根节点

### 比对不同类型的元素
React会拆卸原有的树并建立新的树，元素包括html元素、自定义元素、组件元素。如果用户知道什么时候不应该重新渲染组件，可以通过shouldComponentUpdate告诉React跳过diff。

### 比对同类型元素
保留DOM节点，仅更新有改变的属性。在处理完当前节点后，对子节点进行递归

比对同类型组件元素时，组件实例保持不变，组件state在跨越不同的渲染时保持一致。更新props并调用组件实例的`componentWillReceiveProps()` 和 `componentWillUpdate()` 方法。

### 对子节点进行递归
在默认条件下，当递归DOM节点的子元素时，会同时遍历两个子元素列表，当产生差异时，生成一个mutation。

diff对子元素列表的操作有三种：插入、移动、删除

在子元素列表尾部插入元素比较开销小，在列表头部插入元素开销大，react会针对每个子元素生成一个mutation，也就是说会删除再创建并插入。但是如果能通过`key` prop匹配元素，就能把头部插入元素转换成开销较小的移动和插入了，能最大限度利用已有DOM节点。

## 受控组件
使 React 的 state 成为表单的“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。

### 受控组件vs非受控组件
React 有两种不同的方式来处理表单输入。

如果一个 input 表单元素的值是由 React 控制，就称其为受控组件。当用户将数据输入到受控组件时，会触发修改状态的事件处理器，这时由你的代码来决定此输入是否有效（如果有效就使用更新后的值重新渲染）。如果不重新渲染，则表单元素将保持不变。

一个非受控组件，就像是运行在 React 体系之外的表单元素。当用户将数据输入到表单字段（例如 input，dropdown 等）时，React 不需要做任何事情就可以映射更新后的信息。然而，这也意味着，你无法强制给这个表单字段设置一个特定值。

在大多数情况下，你应该使用受控组件。

## 副作用
数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。

## 高阶组件
高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧，具体而言，高阶组件是参数为组件，返回值为新组件的函数。

## Fiber reconciler
它的主要目标是：
1. 能够把可中断的任务切片处理。
2. 能够调整优先级，重置并复用任务。
3. 能够在父元素与子元素之间交错处理，以支持 React 中的布局。
4. 能够在 render() 中返回多个元素。
5. 更好地支持错误边界。

Fiber实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。Fiber其实是一种数据结构，
```js
const fiber = {
    stateNode,    // 节点实例
    child,        // 子节点
    sibling,      // 兄弟节点
    return,       // 父节点
}
```

任务通过优先级决定执行顺序，优先级高的任务（如键盘输入）可以打断优先级低的任务（如diff）的执行。

Fiber Reconciler 在执行过程中，会分为 2 个阶段。阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。通过这个可打断的特性，能够降低掉帧的概率。

从源码层面说，属于递归改迭代的优化。

[React Fiber 原理介绍](https://segmentfault.com/a/1190000018250127)

