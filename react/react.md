# React

## React diff
传统的diff算法效率低下，算法负责度达到O(n3)。React将Virtual DOM树转换成actual DOM树的最少操作的过程称为调和（reconciliation），diff算法是调和的具体实现。React通过大胆的假设，将O（n3）复杂度的问题转变为O（n）的问题。

### React基于两个假设
1. 两个不同类型的元素会产生出不同的树；
2. 开发者可以通过 `key` prop 来暗示哪些子元素在不同的渲染下能保持稳定；

### React diff的三个策略：
1. Web UI中的DOM节点跨层级的移动操作特别少
2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生产不同的树形结构。
3. 对于同一层级的一组子节点，可以通过唯一id进行区分。

## 树diff

对比两棵树时，首先比较根节点

### 比对不同类型的元素
React会拆卸原有的树并建立新的树，元素包括html元素、自定义元素、组件元素。如果用户知道什么时候不应该重新渲染组件，可以通过shouldComponentUpdate告诉React跳过diff。

### 比对同类型元素
保留DOM节点，仅更新有改变的属性。在处理完当前节点后，对子节点进行递归

比对同类型组件元素时，组件实例保持不变，组件state在跨越不同的渲染时保持一致。更新props并调用组件实例的`componentWillReceiveProps()` 和 `componentWillUpdate()` 方法。

### 对子节点进行递归
在默认条件下，当递归DOM节点的子元素时，会同时遍历两个子元素列表，当产生差异时，生成一个mutation。

diff对子元素列表的操作有三种：插入、移动、删除

在子元素列表尾部插入元素比较开销小，在列表头部插入元素开销大，react会针对每个子元素生成一个mutation，也就是说会删除再创建并插入。但是如果能通过`key` prop匹配元素，就能把头部插入元素转换成开销较小的移动和插入了，能最大限度利用已有DOM节点。

## 受控组件
使 React 的 state 成为表单的“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。

### 受控组件vs非受控组件
React 有两种不同的方式来处理表单输入。

如果一个 input 表单元素的值是由 React 控制，就其称为受控组件。当用户将数据输入到受控组件时，会触发修改状态的事件处理器，这时由你的代码来决定此输入是否有效（如果有效就使用更新后的值重新渲染）。如果不重新渲染，则表单元素将保持不变。

一个非受控组件，就像是运行在 React 体系之外的表单元素。当用户将数据输入到表单字段（例如 input，dropdown 等）时，React 不需要做任何事情就可以映射更新后的信息。然而，这也意味着，你无法强制给这个表单字段设置一个特定值。

在大多数情况下，你应该使用受控组件。

## 副作用
数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。

