# JavaScript 整理

## 作用域
**《JavaScript高级程序设计》第四版**

任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也被称为作用域）。这个上下文（作用域）决定了变量的生存周期，以及它们可以访问代码的哪些部分。

每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量都会存在这个对象上。

执行上下文可以总结如下。
1. 执行上下文可以分为全局上下文、函数上下文和块级上下文。在浏览器中，全局上下文是window对象。
2. 作用域链和上下文栈对应，代码执行流每进入一个新的上下文，不仅会在当前上下文栈顶压入这个新的上下文，还会创建一个将不同上下文的变量对象连在一起的作用域链，用于搜索变量和函数。作用域链的第一个变量对象是当前活动的上下文，下一个变量对象来自包含上下文，再下一个对象来自包含上下文的包含上下文，以此类推直至全局上下文。
3. 函数或块的局部上下文不仅可以访问自己作用域内的变量，还可以通过作用域链访问任何包含上下文乃至全局上下文中的变量。代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的，搜索过程从作用域链的最前端开始，然后逐级往后，直到找到标识符，或者报错。
4. 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。以此类推，包含上下文只能访问从自己到全局上下文中定义的变量，不能访问内部作用域内的变量。
5. 变量的上下文用于确定什么时候释放内存。

## 垃圾回收

1. 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。
2. 主流的垃圾回收算法是标记清理，即给当前不使用的值加上标记，方法有很多，如进入变量进入上下文时反转某一位，或者维护“在上下文”和“不在上下文”两个变量列表。
3. 可以通过解除引用、使用let和const、小心使用闭包等方式优化内存使用。

## 对象

### 属性
对象的属性分为两类：数据属性和访问器属性。

数据属性有四个特性描述它们的行为：configurable、enumerable、writable、value。直接定义到对象上的属性，configurable、enumerable、writable的默认值都是true。

访问器属性也有四个特性描述它们的行为：configurable、enumerable、set、get。访问器属性不能直接定义，必须使用Object.defineProperty()。

在调用Object.defineProperty()时，configurable、enumerable、writable如果不指定，默认值都是false。

### 对象解构
解构在内部使用ToObject()（不能在运行时环境中直接访问）把原数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据ToObject的定义），null和undefined不能被解构，否则会抛出错误。

如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中。

## 原型
每个函数在创建时会按照特定的规则为这个函数创建一个prototype属性（指向原型对象）。默认情况下，所有原型对象自动获得一个constructor属性，指回与之关联的构造函数，默认继承Object。也就是说构造函数的原型对象，其原型是Object的原型。

```js
Person.prototype.__proto__ === Object.prototype; // true
Person.prototype.__proto__.constructor === Object; // true
```

Object原型的原型是null，即正常的原型链都会终止与Object的原型对象
```js
Person.prototype.__proto__.__proto__ === null; // true
```

每次通过构造函数创建的实例，内部[[Prototype]]指针会被赋值为构造函数的原型对象。代码中可以通过非标准的__proto__属性访问实例对象的原型。

构造函数、构造函数的原型对象和实例是三个完全不同的对象。构造函数通过prototype属性链接到原型对象，实例对象通过__proto__链接到原型对象。实例与构造函数没有直接联系，与原型对象有直接联系。

### instanceof
instanceof检查实例的原型链中是否包含指定构造函数的原型。

就算用一个新对象覆盖了构造函数的原型对象，之后通过new创建的实例由于其原型对象就是这个新对象，而这个新对象是构造函数的原型对象，因此instanceof能正确的指示出实例是构造函数的实例。需要注意的是，覆盖原型前后创建的实例，它们的原型对象不同。

### 原型层级
在通过对象访问属性时，会按照这个属性的名称开始搜索，搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。

## 原型链
每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果这里的原型同时还是另一个类型的实例，那么这个原型也有一个内部指针指向另一个原型。相应的，另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。

## 创建对象

### 工厂模式

### 构造函数模式
使用new操作符掉用构造函数会执行操作：
1. 在内存中创建一个对象。
2. 这个新对象的内部[[Prototype]]特性赋值为构造函数的prototype属性
3. 构造函数内部的this被赋值为这个新对象（即this指向新对象）。
4. 执行构造函数内部的代码（给新对象添加属性）。
5. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的对象。

### 原型模式