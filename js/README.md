# JavaScript 整理

## [事件循环](./event-loop//eventloop.md)

## [函数](./function.md)

## 作用域
**《JavaScript高级程序设计》第四版**

任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也被称为作用域）。这个上下文（作用域）决定了变量的生存周期，以及它们可以访问代码的哪些部分。

每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量都会存在这个对象上。

执行上下文可以总结如下。
1. 执行上下文可以分为全局上下文、函数上下文和块级上下文。在浏览器中，全局上下文是window对象。
2. 作用域链和上下文栈对应，代码执行流每进入一个新的上下文，不仅会在当前上下文栈顶压入这个新的上下文，还会创建一个将不同上下文的变量对象连在一起的作用域链，用于搜索变量和函数。作用域链的第一个变量对象是当前活动的上下文，下一个变量对象来自包含上下文，再下一个对象来自包含上下文的包含上下文，以此类推直至全局上下文。
3. 函数或块的局部上下文不仅可以访问自己作用域内的变量，还可以通过作用域链访问任何包含上下文乃至全局上下文中的变量。代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的，搜索过程从作用域链的最前端开始，然后逐级往后，直到找到标识符，或者报错。
4. 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。以此类推，包含上下文只能访问从自己到全局上下文中定义的变量，不能访问内部作用域内的变量。
5. 变量的上下文用于确定什么时候释放内存。

## 垃圾回收

1. 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。
2. 主流的垃圾回收算法是标记清理，即给当前不使用的值加上标记，方法有很多，如进入变量进入上下文时反转某一位，或者维护“在上下文”和“不在上下文”两个变量列表。
3. 可以通过解除引用、使用let和const、小心使用闭包等方式优化内存使用。

## 对象

### 属性
对象的属性分为两类：数据属性和访问器属性。

数据属性有四个特性描述它们的行为：configurable、enumerable、writable、value。直接定义到对象上的属性，configurable、enumerable、writable的默认值都是true。

访问器属性也有四个特性描述它们的行为：configurable、enumerable、set、get。访问器属性不能直接定义，必须使用Object.defineProperty()。

在调用Object.defineProperty()时，configurable、enumerable、writable如果不指定，默认值都是false。

### 对象解构
解构在内部使用ToObject()（不能在运行时环境中直接访问）把原数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据ToObject的定义），null和undefined不能被解构，否则会抛出错误。

如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中。

## 原型
每个函数在创建时会按照特定的规则为这个函数创建一个prototype属性（指向原型对象）。默认情况下，所有原型对象自动获得一个constructor属性，指回与之关联的构造函数，默认继承Object。也就是说构造函数的原型对象，其原型是Object的原型。

```js
Person.prototype.__proto__ === Object.prototype; // true
Person.prototype.__proto__.constructor === Object; // true
```

Object原型的原型是null，即正常的原型链都会终止于Object的原型对象
```js
Person.prototype.__proto__.__proto__ === null; // true
```

每次通过构造函数创建的实例，内部[[Prototype]]指针会被赋值为构造函数的原型对象。代码中可以通过非标准的__proto__属性访问实例对象的原型。

构造函数、构造函数的原型对象和实例是三个完全不同的对象。构造函数通过prototype属性链接到原型对象，实例对象通过__proto__链接到原型对象。实例与构造函数没有直接联系，与原型对象有直接联系。

### instanceof
instanceof检查实例的原型链中是否包含指定构造函数的原型。

就算用一个新对象覆盖了构造函数的原型对象，之后通过new创建的实例由于其原型对象就是这个新对象，而这个新对象是构造函数的原型对象，因此instanceof能正确的指示出实例是构造函数的实例。需要注意的是，覆盖原型前后创建的实例，它们的原型对象不同。

### 原型层级
在通过对象访问属性时，会按照这个属性的名称开始搜索，搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。

给对象实例添加一个属性，这个属性会遮蔽原型对象上的同名属性。

### in操作符
单独使用时，in操作符会在可以通过对象访问指定属性时返回true，无论该属性是在对象实例上还是原型上。

在for-in循环中使用in操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性

## 创建对象
在需要创建具有相同接口的多个对象时很有用的一些模式，按照逐渐优化的顺序排列

### 工厂模式
抽象了创建特定对象的过程，虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题。

### 构造函数模式
使用new操作符掉用构造函数会执行操作：
1. 在内存中创建一个对象。
2. 这个新对象的内部[[Prototype]]特性赋值为构造函数的prototype属性
3. 构造函数内部的this被赋值为这个新对象（即this指向新对象）。
4. 执行构造函数内部的代码（给新对象添加属性）。
5. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的对象。

自定义构造函数可以确保实例被标识为特定类型。

**注意**
1. 构造函数也是函数，以普通形式调用构造函数，如果没有指定this，this指向Global对象（在浏览器中是window对象，nodejs里是一些全局可用的对象，没有所谓的“global”对象，至少从官方文档看起来是这样的）。
2. 构造函数的主要问题在于，其定义的方法在每个实例上都会创建一遍，不同实例上的函数同名却不相等。

### 原型模式
每个函数都会创建一个prototype属性，这个属性是一个对象，是通过构造函数创建的对象的原型。在它上面定义的属性和方法可以被对象实例共享。

## 继承

### 原型链
每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果这里的原型同时还是另一个类型的实例，那么这个原型也有一个内部指针指向另一个原型。相应的，另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。

使用原型链继承的关键是用父类型的实例替换默认原型，于是实例的内部属性可以指向子类型原型，子类型原型作为父类型实例又可以通过内部属性指向父类型原型。搜索就可以沿着继承向上，搜索原型的原型。

注意替换原型后，实例的constructor指向父类型构造函数。

**默认原型**
默认情况下，所有引用类型都通过原型链继承自Object，任何函数的默认原型都是一个Object的实例，因此函数的默认原型有一个内部指针指向Object.prototype。

**问题**
由于原型上的引用值会在实例间共享，通常属性会在构造函数中定义。在使用原型实现继承时，原型实际上变成另一个类型的实例，原先的实例属性就变成了原型属性。

第二个问题时子类型实例化时不能给父类型的构造函数传参。

### 盗用构造函数
相比于原型链，盗用构造函数的优点在于可以在子类构造函数中像父类构造函数传参。

**问题**
和构造函数模式的问题一样，必须在构造函数中定义方法，因此函数不能重用。子类也不能访问父类原型上定义的方法。

### 组合继承
组合继承综合了原型链和盗用构造函数。基本思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数来继承实例属性。组合继承保留了instanceof操作符和isPrototypeOf()方法识别合成对象的能力。

### 原型式继承
即使不自定义类型也可以通过原型实现对象之间的信息共享。具体做法是，创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的实例。核心是通过原型获得其他对象的信息，不关心构造函数和类型。

原型式继承适合一种情况，已有一个对象，在它的基础上再创建一个新对象。和原型模式一样，原型上的引用类型会在衍生对象之间共享。

ECMAScript 5 通过增加Object.create()方法将原型式继承的概念规范化。

### 寄生式继承
和原型式继承类似，寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。背后的思想类似于盗用构造函数和工厂模式，创建一个实现继承的函数，通过原型式继承获得新对象，添加属性来增强新对象，然后返回新对象。简单说，寄生式继承 = 原型式继承 + 添加属性。

**问题**
和构造函数模式类似，给对象添加函数会导致函数难以复用。

### 寄生式组合继承
组合继承中，父类构造函数会调用两次：一次是在创建子类原型时，一次是在子类构造函数中调用。这样会存在两组父类实例属性，一组在实例上，另一组在子类原型上。通过寄生式组合继承可以解决这个问题。

寄生式组合继承通过盗用构造函数继承实例属性，但使用混合式原型继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。也就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。继承方法的模式如下：

```js
function inheritPrototype(subType, superType) {
  let prototype = Object.create(superType.prototype); // 创建对象
  prototype.constructor = subType; // 增强对象，解决由于重写原型导致constructor丢失的问题
  subType.prototype = prototype; // 赋值对象
}
```

继承父类实例属性还是通过盗用构造函数。这样既只调用了一次父类构造函数，用来添加实例属性。而通过寄生式继承获得在父类原型上共享的属性和方法，同时子类原型上也没有不必要的属性，并且原型链仍然正常作用于instanceof操作符和isPrototype()。

## 类

