# JavaScript 整理

## [事件循环](./event-loop//eventloop.md)

## [函数](./function.md)

## 作用域
**《JavaScript高级程序设计》第四版**

任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也被称为作用域）。这个上下文（作用域）决定了变量的生存周期，以及它们可以访问代码的哪些部分。

每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量都会存在这个对象上。全局上下文中的叫变量对象，而函数局部上下文中的叫活动对象。

执行上下文可以总结如下。
1. 执行上下文可以分为全局上下文、函数上下文和块级上下文。在浏览器中，全局上下文是window对象。
2. 在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链，函数的执行上下文通过内部的[[Scope]]引用作用域链，每个函数上下文都有自己的作用域链对象。然后用argumens和其他命名参数来初始化这个函数的活动对象，函数自身的活动对象是作用域链上的第一个对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直至全局上下文才终止。
3. 作用域链其实是一个包含指针的列表。每个指针分别指向一个活动对象，但物理上并不会包含相应的对象。
4. 函数或块的局部上下文不仅可以访问自己作用域内的变量，还可以通过作用域链访问任何包含上下文乃至全局上下文中的变量。代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的，搜索过程从作用域链的最前端开始，然后逐级往后，直到找到标识符，或者报错。
5. 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。以此类推，包含上下文只能访问从自己到全局上下文中定义的变量，不能访问内部作用域内的变量。
6. 变量的上下文用于确定什么时候释放内存。

## 垃圾回收

1. 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。
2. 主流的垃圾回收算法是标记清理，即给当前不使用的值加上标记，方法有很多，如进入变量进入上下文时反转某一位，或者维护“在上下文”和“不在上下文”两个变量列表。
3. 可以通过解除引用、使用let和const、小心使用闭包等方式优化内存使用。

## 对象

### 属性
对象的属性分为两类：数据属性和访问器属性。

数据属性有四个特性描述它们的行为：configurable、enumerable、writable、value。直接定义到对象上的属性，configurable、enumerable、writable的默认值都是true。

访问器属性也有四个特性描述它们的行为：configurable、enumerable、set、get。访问器属性不能直接定义，必须使用Object.defineProperty()。

在调用Object.defineProperty()时，configurable、enumerable、writable如果不指定，默认值都是false。

### 对象解构
解构在内部使用ToObject()（不能在运行时环境中直接访问）把原数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据ToObject的定义），null和undefined不能被解构，否则会抛出错误。

如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中。

## 原型
每个函数在创建时会按照特定的规则为这个函数创建一个prototype属性（指向原型对象）。默认情况下，所有原型对象自动获得一个constructor属性，指回与之关联的构造函数，默认继承Object。也就是说构造函数的原型对象，其原型是Object的原型。

```js
Person.prototype.__proto__ === Object.prototype; // true
Person.prototype.__proto__.constructor === Object; // true
```

Object原型的原型是null，即正常的原型链都会终止于Object的原型对象
```js
Person.prototype.__proto__.__proto__ === null; // true
```

每次通过构造函数创建的实例，内部[[Prototype]]指针会被赋值为构造函数的原型对象。代码中可以通过非标准的__proto__属性访问实例对象的原型。

构造函数、构造函数的原型对象和实例是三个完全不同的对象。

```js
let person1 = new Person();
person1 !== Person; // true
person1 !== Person.prototype; // true
Person.prototype !== Person; // true
```

构造函数通过prototype属性链接到原型对象，实例对象通过__proto__链接到原型对象。实例与构造函数没有直接联系，与原型对象有直接联系。

```js
person1.__proto__ === Person.prototype; // true
person1.__proto__.constructor === Person; // ture
```

### instanceof
instanceof检查实例的原型链中是否包含指定构造函数的原型。

就算用一个新对象覆盖了构造函数的原型对象，之后通过new创建的实例由于其原型对象就是这个新对象，而这个新对象是构造函数的原型对象，因此instanceof能正确的指示出实例是构造函数的实例。需要注意的是，覆盖原型前后创建的实例，它们的原型对象不同。

### 原型层级
在通过对象访问属性时，会按照这个属性的名称开始搜索，搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。

给对象实例添加一个属性，这个属性会遮蔽原型对象上的同名属性。

### in操作符
单独使用时，in操作符会在可以通过对象访问指定属性时返回true，无论该属性是在对象实例上还是原型上。

在for-in循环中使用in操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性

## 创建对象
在需要创建具有相同接口的多个对象时很有用的一些模式，按照逐渐优化的顺序排列

### 工厂模式
抽象了创建特定对象的过程，虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题。

### 构造函数模式
使用new操作符掉用构造函数会执行操作：
1. 在内存中创建一个对象。
2. 这个新对象的内部[[Prototype]]特性赋值为构造函数的prototype属性
3. 构造函数内部的this被赋值为这个新对象（即this指向新对象）。
4. 执行构造函数内部的代码（给新对象添加属性）。
5. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的对象。

用代码简单模拟new
```js
function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ ...params) {
  // 创建一个空对象，继承构造函数的prototype属性
  const context = Object.create(constructor.prototype);
  // 执行构造函数
  const result = constructor.apply(context, params);
  // 如果返回结果是对象，就直接返回，否则返回context对象
  return (typeof result === 'Object' && result !== null) ? result : context;
}
```

自定义构造函数可以确保实例被标识为特定类型。

**注意**

1. 构造函数也是函数，以普通形式调用构造函数，如果没有指定this，this指向Global对象（在浏览器中是window对象，nodejs里是一些全局可用的对象，没有所谓的“global”对象，至少从官方文档看起来是这样的）。
2. 构造函数的主要问题在于，其定义的方法在每个实例上都会创建一遍，不同实例上的函数同名却不相等。

### 原型模式
每个函数都会创建一个prototype属性，这个属性是一个对象，是通过构造函数创建的对象的原型。在它上面定义的属性和方法可以被对象实例共享。

## 继承

### 原型链
每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果这里的原型同时还是另一个类型的实例，那么这个原型也有一个内部指针指向另一个原型。相应的，另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。

使用原型链继承的关键是用父类型的实例替换默认原型，于是实例的内部属性可以指向子类型原型，子类型原型作为父类型实例又可以通过内部属性指向父类型原型。搜索就可以沿着继承向上，搜索原型的原型。

注意替换原型后，实例的constructor指向父类型构造函数。

**默认原型**

默认情况下，所有引用类型都通过原型链继承自Object，任何函数的默认原型都是一个Object的实例，因此函数的默认原型有一个内部指针指向Object.prototype。

**问题**

由于原型上的引用值属性会在实例间共享，为了避免实例意外修改引用值，通常属性会在构造函数中定义。在使用原型实现继承时，原型实际上变成另一个类型的实例，原先的实例属性就变成了原型属性。

第二个问题时子类型实例化时不能给父类型的构造函数传参。

### 盗用构造函数
为了解决原型包含引用值导致的继承问题，出现了盗用构造函数的继承方式，基本思路是在子类构造函数中调用父类构造函数。相比于原型链，盗用构造函数的优点在于可以在子类构造函数中像父类构造函数传参。

**问题**

和构造函数模式的问题一样，必须在构造函数中定义方法，因此函数不能重用。子类也不能访问父类原型上定义的方法。

### 组合继承
组合继承综合了原型链和盗用构造函数。基本思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数来继承实例属性。组合继承保留了instanceof操作符和isPrototypeOf()方法识别合成对象的能力。

### 原型式继承
即使不自定义类型也可以通过原型实现对象之间的信息共享。具体做法是，创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的实例。核心是通过原型链获得其他对象的信息，不关心构造函数和类型。

原型式继承适合一种情况，已有一个对象，在它的基础上再创建一个新对象。和原型模式一样，原型上的引用类型会在衍生对象之间共享。

ECMAScript 5 通过增加Object.create()方法将原型式继承的概念规范化。

### 寄生式继承
和原型式继承类似，寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。背后的思想类似于盗用构造函数和工厂模式，创建一个实现继承的函数，通过原型式继承获得新对象，添加属性来增强新对象，然后返回新对象。简单说，寄生式继承 = 原型式继承 + 添加属性。

**问题**

和构造函数模式类似，给对象添加函数会导致函数难以复用。

### 寄生式组合继承
组合继承中，父类构造函数会调用两次：一次是在创建子类原型时，一次是在子类构造函数中调用。这样会存在两组父类实例属性，一组在实例上，另一组在子类原型上。通过寄生式组合继承可以解决这个问题。

寄生式组合继承通过盗用构造函数继承实例属性，但使用混合式原型继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。也就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。继承方法的模式如下：

```js
function inheritPrototype(subType, superType) {
  let prototype = Object.create(superType.prototype); // 创建对象
  prototype.constructor = subType; // 增强对象，解决由于重写原型导致constructor丢失的问题
  subType.prototype = prototype; // 赋值对象
}
```

继承父类实例属性还是通过盗用构造函数。这样既只调用了一次父类构造函数，用来添加实例属性。而通过寄生式继承获得在父类原型上共享的属性和方法，同时子类原型上也没有不必要的属性，并且原型链仍然正常作用于instanceof操作符和isPrototype()。

## 类

### 类的构成
类可以包含构造函数、实例成员、访问器、原型方法、静态成员，但都不是必须的。

类定义中的代码默认都在严格模式下执行。类中的方法（包括实例方法和原型方法）中的this默认为实例，但是如果取出来单独使用，由于类内部为严格模式，实际为undefined。解决办法：一个是在构造函数内绑定this，另一个是在构造函数中用箭头函数定义方法。

### 类的定义
类的定义不存在提升，类表达式和函数表达式一样，不能提升，类声明和函数声明不一样，函数声明会提升，类声明不会。

类声明受块作用域限制，函数声明受函数作用域限制。

### 类构造函数
调用类构造函数必须用new。实例化后变为普通的实例方法，可以在实例上通过constructor属性引用它，但还是需要使用new调用。

类本身具有与普通构造函数一样的行为，在类的上下文中，类本身在使用new调用时就会被当作构造函数。

```js
class Person {}

let p1 = new Person();

p1.constructor === Person; // true
p1 instanceof Person; // true
p1 instanceof Person.constructor; // false

```
其实说明类构造函数与其他类方法（也就是原型方法）一样是定义在原型上的，这一点跟普通构造函数保持一致。 ``` Person.prototype.constructor === Person ```。

类也可以像函数或其他对象一样作为参数被引用，说明类本质上就是一种特殊函数，也可以立即实例化。

### 静态成员
静态成员在类定义中使用```static```关键字作为前缀，this引用类自身，实际是定义在类上。

## 类的继承
类不仅可以继承类，也可以继承普通构造函数。

派生类通过原型链访问到类和原型上的方法。this的值会反映调用相应方法的实例或者类。

### super关键字
只能在派生类中使用，也就是必须要用extends继承一个类。

在构造函数中，super() 相当于 super.constructor()，this只能在super()调用之后使用。

在静态方法中，可以通过super调用继承的类上的静态方法。

### new.target
new.target保存通过new关键字调用的类或函数，可以通过```new.target === Person```的形式实现抽象基类的效果。

## var声明提升
所有var变量声明都拉到函数作用域的顶部。此外，反复多次使用var声明同一个变量也没有问题。

## 迭代器（Iterator）
“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。

“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。

把实现了Iterable接口，可以通过迭代器Iterator消费的对象称为“可迭代对象”。实现Iterable接口必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的Symbol.iterator作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个迭代器。

很多内置类型都实现了Iterable接口：
1. 字符串
2. 数组
3. 映射（Map）
4. 集合（Set）
5. arguments对象
6. NodeList等DOM集合类型

不需要显示调用这个工厂函数来生成迭代器。实现Iterable接口的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：
1. for of循环
2. 数组解构
3. 扩展运算符
4. Array.from()
5. 创建集合
6. 创建映射
7. Promise.all()接收由期约组成的可迭代对象
8. Promise.race()接收由期约组成的可迭代对象
9. yield* 操作符，在生成器中使用

这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器。

如果对象原型链上的父类实现了Iterable接口，那这个对象也就实现了这个接口。

迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象，不同的迭代器实例之间没有联系，只会独立的遍历可迭代对象。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映变化。

**注意**

迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。

可选的return()方法用于指定在迭代器提前关闭时执行的逻辑。数组的迭代器是不能关闭的，还可以继续从上次离开的地方继续迭代。仅仅给一个不可关闭的迭代器增加return方法作为属性**并不能**让它变成可关闭的。

## 生成器（Generator）
箭头函数不能用来定义生成器。

调用生成器函数会产生一个生成器对象。生成器对象一开始处于suspended状态。生成器对象实现了Iterator接口。

生成器函数只会在初次调用产生的生成器对象的next方法后开始执行。

生成器对象实现了Iterable接口，它们默认的迭代器是自引用的：
```js
function* generatorFn() {}

const g = generatorFn();

g === g[Symbol.iterator](); // true;
```

yield关键字可以让生成器停止和开始执行。生成器函数在遇到yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。

生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用next()不会影响到其他生成器。

yield关键字只能在生成器函数内部使用。

生成器对象可以当成可迭代对象来使用。

上一次让生成器函数暂停的yield关键字会接收到传给next()方法的第一个值。第一次调用next()传入的值不会被使用，因为这一次是为了开始执行生成器函数。

yield* 可以迭代一个可迭代对象，一次产出一个值。yield* 实际上只是将一个可迭代对象序列化为一连串可以单独产出的值。

与迭代器不同，所有生成器对象都有return()方法，只要通过它进入关闭状态，就无法恢复了。

生成器对象的throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中，如果错误未被处理，生成器就会关闭。如果生成器函数内部处理了这个错误，那么生成器就不会关闭，还能恢复执行。错误处理会跳过对应的yield，通常会跳过一个值。

**注意**

如果生成器对象还没有开始执行，那么调用throw()抛出的错误不会在函数内部被捕获，因为这相当于在函数体外抛出了错误。


